<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="32x32" src="/others/pulse.png">
  <title>Pulse - DM with <%= targetUser.username %></title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    .message-area::-webkit-scrollbar {
      width: 8px;
    }

    .message-area::-webkit-scrollbar-track {
      background: #2d3748;
    }

    .message-area::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }

    .message-area::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }

    body::-webkit-scrollbar {
      width: 4px;
    }

    body::-webkit-scrollbar-track {
      background: #1e1e1e;
    }

    body::-webkit-scrollbar-thumb {
      background: #7289da;
    }

    body::-webkit-scrollbar-thumb:hover {
      background: #6372e9;
    }
  </style>
</head>

<body
  class="bg-gradient-to-r from-gray-900 to-gray-800 font-sans text-white antialiased min-h-screen flex">

  <div
    class="flex flex-col flex-1 {{ 'ml-14 transition-all duration-200 hover:ml-40' if sidebar was present }}">
    <div class="sticky top-0 z-20">
      <header class="bg-gray-900 border-b border-gray-700 p-4 flex items-center shadow-md sticky top-0 z-20">
        <a href="/dashboard" class="mr-3">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
            stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
          </svg>
        </a>
        <img src="<%= targetUser.profilepicture %>" alt="<%= targetUser.username %> Profile"
          class="w-10 h-10 rounded-full mr-3" />
        <div class="flex flex-col">
          <h1 class="text-xl font-semibold"><%= targetUser.username %></h1>
          <p class="text-sm text-gray-400">Online</p>
        </div>
        <div class="ml-auto flex items-center space-x-2">
          <button id="screenshareButton" class="p-2 rounded-full hover:bg-gray-700">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M9.75 17L9 20l-1 1h8l-1-1-1.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z">
              </path>
            </svg>
          </button>
        </div>
      </header>

      <div id="callInteractionWrapper" class="sticky top-20 z-10">
        <div id="callActions" class="bg-gray-900 border-b border-gray-700 p-2 text-center text-sm">
          <button id="startCallButton" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full mr-2">Start Call</button>
          <button id="joinCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full hidden">Join Call</button>
        </div>

        <div id="callStatus" class="bg-gray-800 p-2 text-center text-sm hidden"></div>
        <div id="callControls" class="bg-gray-800 p-2 text-center text-sm hidden">
          <div id="callParticipants" class="flex items-center justify-center space-x-2 mb-2">
         </div>
         <button id="muteButton" class="p-2 rounded-full hover:bg-gray-700">Mute</button>
         <button id="hangupButton" class="p-2 rounded-full hover:bg-red-700">Leave Call</button>
       </div>
      </div>

    <div id="screenshareContainer" class="flex flex-wrap justify-center p-4 bg-gray-800 hidden sticky top-32 z-10">
    </div>

    <main class="flex-1 p-4 overflow-y-auto message-area">
      <div id="messages" class="space-y-4">
        <% messages.forEach(message => { %>
        <div class="mb-2">
          <div class="flex items-start">
            <img src="<%= message.senderId === user.id ? user.profilepicture : targetUser.profilepicture %>" alt="<%= message.senderId === user.id ? user.username : targetUser.username %> Profile"
              class="w-8 h-8 rounded-full mr-3">
            <div>
              <div class="font-semibold"><%= message.senderId === user.id ? user.username : targetUser.username %></div>
              <% if (message.type === 'image') { %>
              <div class="bg-<%= message.senderId === user.id ? 'blue-700' : 'gray-700' %> text-white p-3 rounded-xl max-w-xs break-words shadow-md">
                <img src="<%= message.content %>" alt="Image" class="max-w-xs rounded-xl shadow-md" />
                <div class="text-xs text-<%= message.senderId === user.id ? 'blue-200' : 'gray-400' %> mt-1 text-<%= message.senderId === user.id ? 'right' : 'left' %>">
                  <%= new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) %>
                </div>
              </div>
              <% } else { %>
              <div class="bg-<%= message.senderId === user.id ? 'blue-700' : 'gray-700' %> text-white p-3 rounded-xl max-w-xs break-words shadow-md">
                <span class="encrypted-message" data-encrypted-content="<%= message.content %>">Loading...</span>
                <div class="text-xs text-<%= message.senderId === user.id ? 'blue-200' : 'gray-400' %> mt-1 text-<%= message.senderId === user.id ? 'right' : 'left' %>">
                  <%= new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) %>
                </div>
              </div>
              <% } %>
            </div>
          </div>
        </div>
        <% }) %>
      </div>
    </main>

    <div class="bg-gray-900 border-t border-gray-700 p-4 sticky bottom-0">
      <form id="messageForm" class="flex items-center gap-4">
        <input type="text" id="messageInput" placeholder="Type your message..."
          class="flex-grow p-3 rounded-full bg-gray-800 text-white focus:bg-gray-700 outline-none transition"
          autocomplete="off" />
        <div id="emojiSuggestions"
          class="absolute bottom-full left-0 mb-2 w-full bg-gray-800 rounded-lg shadow-lg p-2 hidden z-20 max-h-48 overflow-y-auto">
        </div>
        <input type="file" id="fileInput" class="hidden" accept="image/*, image/gif" />
        <div class="relative">
          <label for="fileInput"
            class="cursor-pointer p-3 rounded-full hover:bg-gray-700 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13">
              </path>
            </svg>
          </label>
        </div>
        <button type="submit"
          class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-md transition duration-300">
          Send
        </button>
      </form>
      <div id="imagePreview" class="mt-2"></div>
    </div>
  </div>

<script>
    window.onload = function() {
      window.scrollTo(0,document.body.scrollHeight);
    };

    document.addEventListener('DOMContentLoaded', () => {
      const messageArea = document.querySelector('.message-area');
      const messageForm = document.getElementById('messageForm');
      const messageInput = document.getElementById('messageInput');
      const messagesDiv = document.getElementById('messages');
      const fileInput = document.getElementById('fileInput');
      const imagePreview = document.getElementById('imagePreview');
      let currentImageFile = null;

      const customEmojis = {
        'cry': '/others/emojis/cry.png',
        'blue-what': '/others/emojis/blue-what.png',
        'cool-guy2': '/others/emojis/cool-guy2.png',
        'what': '/others/emojis/what.png',
        'cool-guy': '/others/emojis/cool-guy.png',
        'very-happy-troll': '/others/emojis/very-happy-troll.png'
      };

      function replaceEmojis(text) {
        let replacedText = text;
        let isOnlyEmoji = true;
        let emojiCount = 0;

        let tempText = text;
        for (const emojiName in customEmojis) {
          const regex = new RegExp(`:${emojiName}:`, 'g');
          if (tempText.match(regex)) {
            emojiCount += (tempText.match(regex) || []).length;
            tempText = tempText.replace(regex, '');
          }
        }

        if (tempText.trim().length > 0 || emojiCount === 0) {
          isOnlyEmoji = false;
        }

        for (const emojiName in customEmojis) {
          const regex = new RegExp(`:${emojiName}:`, 'g');
          const emojiClass = isOnlyEmoji ? 'inline-block w-16 h-16 align-middle' : 'inline-block w-5 h-5 align-text-bottom';
          replacedText = replacedText.replace(regex, `<img src="${customEmojis[emojiName]}" alt="${emojiName}" class="${emojiClass}" />`);
        }
        return replacedText;
      }

      const CDN_BASE_URL = 'https://cdn.hyghj.eu.org';
      const CDN_UPLOAD_PATH = '/upload';
      const AUTH_TOKEN = '88740246818a333ee9f24ce2a5ad73af';


      function scrollToBottom() {
        window.scrollTo(0, document.body.scrollHeight);
      }

      function decryptExistingMessages() {
        const secretKey = 'my-secret-key';

        document.querySelectorAll('.encrypted-message').forEach(span => {
          const encryptedContent = span.dataset.encryptedContent;
          if (encryptedContent) {
            try {
              let decryptedContent = CryptoJS.AES.decrypt(encryptedContent, secretKey).toString(CryptoJS.enc.Utf8);
              decryptedContent = replaceEmojis(decryptedContent);
              span.innerHTML = decryptedContent;
            } catch (error) {
              console.error('Decryption error for existing message:', error);
              span.textContent = 'Failed to decrypt message';
            }
          }
        });
      }

      const checkCryptoJSInterval = setInterval(() => {
        if (typeof CryptoJS !== 'undefined' && CryptoJS.AES) {
          clearInterval(checkCryptoJSInterval);
          decryptExistingMessages();
        }
      }, 100);

      const observer = new MutationObserver(() => {
        scrollToBottom();
      });

      observer.observe(messagesDiv, { childList: true });

function displayMessage(msg) {
        const isCurrentUser = msg.senderId === '<%= user.id %>';

        const messageContainer = document.createElement('div');
        messageContainer.classList.add('mb-2');

        messageContainer.innerHTML = `
          <div class="flex items-start ${isCurrentUser ? 'flex-row-reverse' : ''}">
            <img src="${isCurrentUser ? '<%= user.profilepicture %>' : '<%= targetUser.profilepicture %>'} " alt="${isCurrentUser ? '<%= user.username %>' : '<%= targetUser.username %>'} Profile"
              class="w-8 h-8 rounded-full mr-3">
            <div>
              <div class="font-semibold ${isCurrentUser ? 'text-right' : 'text-left'}">${isCurrentUser ? '<%= user.username %>' : '<%= targetUser.username %>'}</div>
              <div class="bg-${isCurrentUser ? 'blue-700' : 'gray-700'} text-white p-3 rounded-xl max-w-xs break-words shadow-md">
                ${msg.type === 'image' ? `<img src="${msg.content}" alt="Image" class="max-w-xs rounded-xl shadow-md" />` : decryptMessage(msg.content)}
                <div class="text-xs text-${isCurrentUser ? 'blue-200' : 'gray-400'} mt-1 text-${isCurrentUser ? 'right' : 'left'}">
                  ${new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </div>
              </div>
            </div>
          </div>
        `;
console.log('Message content:', msg.content);
        messagesDiv.appendChild(messageContainer);
        scrollToBottom();
      }

function decryptMessage(encryptedContent) {
  const secretKey = 'my-secret-key';
  try {
    let decryptedContent = CryptoJS.AES.decrypt(encryptedContent, secretKey).toString(CryptoJS.enc.Utf8);
    decryptedContent = replaceEmojis(decryptedContent);
    return decryptedContent;
  } catch (error) {
    console.error('Decryption error:', error);
    return encryptedContent;
  }
}

      socket.on('chat message', (msg) => {
        console.log('Message received:', msg);
        displayMessage(msg);
      });

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          currentImageFile = file;
          imagePreview.innerHTML = `<img src="${URL.createObjectURL(file)}" alt="Preview" class="max-h-48 rounded-xl" />`;
        } else {
          currentImageFile = null;
          imagePreview.innerHTML = '';
        }
      });

      document.addEventListener('paste', async (event) => {
        const items = (event.clipboardData || event.clipboardData).items;
        let blob = null;

        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf("image") === 0) {
            blob = items[i].getAsFile();
            break;
          }
        }

          if (blob) {
            currentImageFile = blob;
            imagePreview.innerHTML = `<img src="${URL.createObjectURL(blob)}" alt="Preview" class="max-h-48 rounded-xl" />`;
            fileInput.value = '';
          }
      });

      async function uploadImageToCDN(file) {
        const formData = new FormData();
        const filename = `image-${Math.random().toString(36).substring(2, 22)}.png`;
        formData.append('file', file, filename);
        formData.append('folder', 'image');
        formData.append('filename', filename);
 
        try {
          const response = await fetch(CDN_BASE_URL + CDN_UPLOAD_PATH, {
            method: 'POST',
            headers: {
              'Authorization': AUTH_TOKEN,
            },
            body: formData,
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error('CDN Upload Failed:', response.status, response.statusText, errorText);
            alert(`CDN Upload Failed: ${response.status} ${response.statusText} - ${errorText}`);
            throw new Error(`CDN Upload Failed: ${response.status} ${response.statusText} - ${errorText}`);
          }

          const data = await response.json();
          console.log('CDN Upload Response (full data):', data);
          if (data && data.fileUrl) {
            return CDN_BASE_URL + data.fileUrl;
          } else {
            console.error('CDN Upload Response did not contain a fileUrl:', data);
            alert('Failed to upload image: CDN response missing fileUrl. Check console for full response.');
            return null;
          }
        } catch (error) {
          console.error('Error uploading image:', error);
          alert('Failed to upload image. Please try again. Check the console for details.');
          return null;
        }
      }

      messageForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const messageContent = messageInput.value.trim();

        if (!messageContent && !currentImageFile) return;

        let imageUrl = null;

        if (currentImageFile) {
          imageUrl = await uploadImageToCDN(currentImageFile);
        }

        if (imageUrl) {
          console.log('Emitting image message:', {
            senderId: '<%= user.id %>',
            receiverId: '<%= targetUser.id %>',
            type: 'image',
            content: imageUrl
          });
          socket.emit('chat message', {
            senderId: '<%= user.id %>',
            receiverId: '<%= targetUser.id %>',
            type: 'image',
            content: imageUrl
          });
          imagePreview.innerHTML = '';
          fileInput.value = '';
          currentImageFile = null;
          scrollToBottom();
        } else if (currentImageFile) {
          console.error('Image URL is null, not emitting image message.');
          alert('Image upload failed, cannot send image message.');
        }

        if (messageContent) {
          socket.emit('chat message', {
            senderId: '<%= user.id %>',
            receiverId: '<%= targetUser.id %>',
            type: 'text',
            content: messageContent
          });
          messageInput.value = '';
          scrollToBottom();
        }
      });

      messageInput.addEventListener('input', () => {
        const text = messageInput.value;
        const colonIndex = text.lastIndexOf(':');

        if (colonIndex > -1 && (colonIndex === 0 || text[colonIndex - 1] === ' ' || text[colonIndex - 1] === '\n')) {
          const searchTerm = text.substring(colonIndex + 1).toLowerCase();
          const matchingEmojis = Object.keys(customEmojis).filter(emojiName =>
            emojiName.toLowerCase().startsWith(searchTerm)
          );

          displayEmojiSuggestions(matchingEmojis, colonIndex);
        } else {
          const emojiSuggestionsDiv = document.getElementById('emojiSuggestions');
          emojiSuggestionsDiv.classList.add('hidden');
          emojiSuggestionsDiv.innerHTML = '';
        }
      });

      const emojiSuggestionsDiv = document.getElementById('emojiSuggestions');

      function displayEmojiSuggestions(emojis, colonIndex) {
        emojiSuggestionsDiv.innerHTML = '';
        if (emojis.length > 0) {
          emojis.forEach(emojiName => {
            const emojiItem = document.createElement('div');
            emojiItem.classList.add('p-2', 'hover:bg-gray-700', 'cursor-pointer', 'flex', 'items-center');
            emojiItem.innerHTML = `<img src="${customEmojis[emojiName]}" alt="${emojiName}" class="inline-block w-5 h-5 mr-2" /> :${emojiName}:`;
            emojiItem.addEventListener('click', () => {
              const currentText = messageInput.value;
              const newText = currentText.substring(0, colonIndex) + `:${emojiName}: `;
              messageInput.value = newText;
              emojiSuggestionsDiv.classList.add('hidden');
              emojiSuggestionsDiv.innerHTML = '';
              messageInput.focus();
            });
            emojiSuggestionsDiv.appendChild(emojiItem);
          });
          emojiSuggestionsDiv.classList.remove('hidden');
        } else {
          emojiSuggestionsDiv.classList.add('hidden');
        }
      }

      document.addEventListener('click', (e) => {
        if (!emojiSuggestionsDiv.contains(e.target) && e.target !== messageInput) {
          emojiSuggestionsDiv.classList.add('hidden');
        }
      });
    });

    const socket = io(); 
    socket.emit('joinRoom', '<%= user.id %>');

    function getDmRoomId(userId1, userId2) {
      return [userId1, userId2].sort().join('-');
    }

    const targetUserId = '<%= targetUser.id %>';
    const currentUserId = '<%= user.id %>';
    const dmRoomId = getDmRoomId(currentUserId, targetUserId);

    const startCallButton = document.getElementById('startCallButton');
    const joinCallButton = document.getElementById('joinCallButton');
    const screenshareButton = document.getElementById('screenshareButton');
    const callStatusDiv = document.getElementById('callStatus');
    const callControlsDiv = document.getElementById('callControls');
    const callParticipantsDiv = document.getElementById('callParticipants');
    const muteButton = document.getElementById('muteButton');
    const hangupButton = document.getElementById('hangupButton');
    const screenshareContainer = document.getElementById('screenshareContainer');
    const callActionsDiv = document.getElementById('callActions');

    let peerConnections = {};
    let localStream;
    let screenShareStream;
    let isMuted = false;
    let isSharingScreen = false;
    let callState = null;

    const iceServers = {
      'iceServers': [
        { 'urls': 'stun:stun.l.google.com:19302' },
        { 'urls': 'stun:stun1.l.google.com:19302' },
      ]
    };

    startCallButton.addEventListener('click', async () => {
      if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
        localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
      }
      socket.emit('start-call', { callerId: currentUserId, targetUserId: targetUserId });
    });
    joinCallButton.addEventListener('click', async () => {
      if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
        localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
      }
      socket.emit('join-call', { userId: currentUserId, targetUserId: targetUserId });
    });


    socket.on('webrtc-signal', async (data) => {
      const { dmRoomId: signalDmRoomId, senderId, type, sdp, candidate } = data;
      if (signalDmRoomId !== dmRoomId) {
        console.warn('Received WebRTC signal for a different DM room, ignoring.', signalDmRoomId, dmRoomId);
        return;
      }

      if (senderId === currentUserId) {
        return;
      }

      let pc = peerConnections[senderId];
      if (!pc) {
        pc = await startPeerConnection(senderId, false);
      }

      try {
        if (type === 'offer') {
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('webrtc-signal', {
            dmRoomId: dmRoomId,
            targetUserId: senderId,
            senderId: currentUserId,
            type: 'answer',
            sdp: pc.localDescription
          });
        } else if (type === 'answer') {
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        } else if (type === 'ice-candidate') {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } else if (type === 'screenshare-offer') {
          handleScreenshareOffer(data);
        } else if (type === 'screenshare-answer') {
          handleScreenshareAnswer(data);
        } else if (type === 'screenshare-ice-candidate') {
          handleScreenshareIceCandidate(data);
        } else if (type === 'screenshare-end') {
          handleScreenshareEnd(data);
        }
      } catch (error) {
        console.error('Error handling WebRTC signal:', type, error);
      }
    });

    muteButton.addEventListener('click', () => {
      if (localStream) {
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
      } else {
        console.warn('Cannot mute/unmute: localStream is not available.');
      }
    });

    hangupButton.addEventListener('click', () => {
      socket.emit('leave-call', { userId: currentUserId, targetUserId: targetUserId });
      handleCallEnd();
    });
    function handleCallEnd() {
      for (const peerId in peerConnections) {
        if (peerConnections[peerId]) {
          peerConnections[peerId].close();
          delete peerConnections[peerId];
        }
      }
      peerConnections = {};

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (screenShareStream) {
        screenShareStream.getTracks().forEach(track => track.stop());
        screenShareStream = null;
      }
      isSharingScreen = false;
      screenshareButton.textContent = 'Screenshare';
      screenshareContainer.innerHTML = '';
      screenshareContainer.classList.add('hidden');

      callStatusDiv.textContent = 'Call Disconnected';
      callStatusDiv.classList.add('hidden');
      callControlsDiv.classList.add('hidden');
      callActionsDiv.classList.remove('hidden');
      startCallButton.classList.remove('hidden');
      joinCallButton.classList.add('hidden');
      callParticipantsDiv.innerHTML = '';
      callState = null;
    }
    let screensharePeerConnections = {};

    screenshareButton.addEventListener('click', async () => {
      if (isSharingScreen) {
        stopScreenshare();
      } else {
        startScreenshare();
      }
    });

    async function startScreenshare() {
      try {
        screenShareStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        isSharingScreen = true;
        screenshareButton.textContent = 'Stop Screenshare';
        screenshareContainer.classList.remove('hidden');

        displayScreenshareStream(screenShareStream, currentUserId);
        if (callState && callState.participants) {
          for (const participantId of callState.participants) {
            if (participantId !== currentUserId) {
              const screensharePc = new RTCPeerConnection(iceServers);
              screensharePeerConnections[participantId] = screensharePc;
              screenShareStream.getTracks().forEach(track => screensharePc.addTrack(track, screenShareStream));

              screensharePc.onicecandidate = (event) => {
                if (event.candidate) {
                  socket.emit('webrtc-signal', {
                    dmRoomId: dmRoomId,
                    targetUserId: participantId,
                    senderId: currentUserId,
                    type: 'screenshare-ice-candidate',
                    candidate: event.candidate
                  });
                }
              };

              const offer = await screensharePc.createOffer();
              await screensharePc.setLocalDescription(offer);
              socket.emit('webrtc-signal', {
                dmRoomId: dmRoomId,
                targetUserId: participantId,
                senderId: currentUserId,
                type: 'screenshare-offer',
                sdp: screensharePc.localDescription
              });
            }
          }
        }

        screenShareStream.getVideoTracks()[0].onended = () => {
          stopScreenshare();
        };

      } catch (error) {
        console.error('Error starting screenshare:', error);
        isSharingScreen = false;
        screenshareButton.textContent = 'Screenshare';
        removeScreenshareStream(currentUserId);
      }
    }
    function stopScreenshare() {
      if (screenShareStream) {
        screenShareStream.getTracks().forEach(track => track.stop());
        screenShareStream = null;
      }

      for (const participantId in screensharePeerConnections) {
        if (screensharePeerConnections[participantId]) {
          screensharePeerConnections[participantId].close();
          delete screensharePeerConnections[participantId];
        }
      }
      screensharePeerConnections = {};

      isSharingScreen = false;
      screenshareButton.textContent = 'Screenshare';

      socket.emit('webrtc-signal', {
        dmRoomId: dmRoomId,
        senderId: currentUserId,
        type: 'screenshare-end'
      });
      removeScreenshareStream(currentUserId);
    }
    async function startPeerConnection(remoteUserId, isInitiator) {
      if (peerConnections[remoteUserId]) {
        console.log(`Peer connection to ${remoteUserId} already exists.`);
        return peerConnections[remoteUserId];
      }

      const pc = new RTCPeerConnection(iceServers);
      peerConnections[remoteUserId] = pc;

      if (localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      } else {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
        localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
      }
      pc.ontrack = (event) => {
        console.log('Remote track received from:', remoteUserId, event.track);
        const remoteAudio = new Audio();
        remoteAudio.srcObject = event.streams[0];
        remoteAudio.play();
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('webrtc-signal', {
            dmRoomId: dmRoomId,
            targetUserId: remoteUserId,
            senderId: currentUserId,
            type: 'ice-candidate',
            candidate: event.candidate
          });
        }
      };

      if (isInitiator) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('webrtc-signal', {
          dmRoomId: dmRoomId,
          targetUserId: remoteUserId,
          senderId: currentUserId,
          type: 'offer',
          sdp: pc.localDescription
        });
      }
      return pc;
    }
    async function joinCallRoom() {
      callStatusDiv.textContent = 'Connecting...';
      callStatusDiv.classList.remove('hidden');
      callControlsDiv.classList.remove('hidden');
      callActionsDiv.classList.add('hidden');
      if (callState && callState.participants) {
        for (const participantId of callState.participants) {
          if (participantId !== currentUserId) {
            await startPeerConnection(participantId, true);
          }
        }
      }
    }
    socket.on('call-state-update', async (data) => {
      const { dmRoomId: updatedDmRoomId, call } = data;
      if (updatedDmRoomId !== dmRoomId) {
        console.warn('Received call-state-update for a different DM room, ignoring.', updatedDmRoomId, dmRoomId);
        return;
      }
      callState = call;
      if (callState) {
        callActionsDiv.classList.add('hidden');
        callControlsDiv.classList.remove('hidden');
        callStatusDiv.classList.remove('hidden');
        callStatusDiv.textContent = 'Call Active';
        callParticipantsDiv.innerHTML = '';
        const usersInCall = await Promise.all(callState.participants.map(async (pId) => {
          if (pId === currentUserId) {
            return { id: currentUserId, username: '<%= user.username %>', profilepicture: '<%= user.profilepicture %>' };
          } else {
            try {
              const response = await fetch(`/api/user/${pId}`);
              return await response.json();
            } catch (error) {
              console.error('Error fetching participant username:', error);
              return { id: pId, username: 'Unknown User', profilepicture: '/others/pulse.png' };
            }
          }
        }));
        usersInCall.forEach(p => {
          const participantElement = document.createElement('div');
          participantElement.classList.add('flex', 'items-center', 'space-x-1');
          participantElement.innerHTML = `
            <img src="${p.profilepicture}" alt="${p.username} Profile" class="w-6 h-6 rounded-full">
            <span class="text-sm">${p.username}</span>
          `;
          callParticipantsDiv.appendChild(participantElement);
        });
        const currentParticipants = Object.keys(peerConnections);
        const newParticipants = callState.participants.filter(pId => pId !== currentUserId && !currentParticipants.includes(pId));
        const leavingParticipants = currentParticipants.filter(pId => !callState.participants.includes(pId));
        for (const newPId of newParticipants) {
          await startPeerConnection(newPId, true);
        }
        for (const leavingPId of leavingParticipants) {
          if (peerConnections[leavingPId]) {
            peerConnections[leavingPId].close();
            delete peerConnections[leavingPId];
            console.log(`Closed peer connection to leaving participant: ${leavingPId}`);
          }
        }
      } else {
        handleCallEnd();
        callActionsDiv.classList.remove('hidden');
        startCallButton.classList.remove('hidden');
        joinCallButton.classList.add('hidden');
      }
      if (callState && callState.participants.length > 0 && !callState.participants.includes(currentUserId)) {
        joinCallButton.classList.remove('hidden');
        startCallButton.classList.add('hidden');
      } else if (callState && callState.participants.includes(currentUserId)) {
        startCallButton.classList.add('hidden');
        joinCallButton.classList.add('hidden');
      } else {
        startCallButton.classList.remove('hidden');
        joinCallButton.classList.add('hidden');
      }
    });
    async function handleScreenshareOffer(data) {
      const senderId = data.senderId;
      let screensharePc = screensharePeerConnections[senderId];
      if (!screensharePc) {
        screensharePc = new RTCPeerConnection(iceServers);
        screensharePeerConnections[senderId] = screensharePc;
        screensharePc.ontrack = (event) => {
          console.log('Remote screenshare track received (callee):', event.track);
          displayScreenshareStream(event.streams[0], senderId);
        };
        screensharePc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('webrtc-signal', {
              dmRoomId: dmRoomId,
              targetUserId: senderId,
              senderId: currentUserId,
              type: 'screenshare-ice-candidate',
              candidate: event.candidate
            });
          }
        };
      }
      await screensharePc.setRemoteDescription(new RTCSessionDescription(data.sdp));
      const answer = await screensharePc.createAnswer();
      await screensharePc.setLocalDescription(answer);
      socket.emit('webrtc-signal', {
        dmRoomId: dmRoomId,
        targetUserId: senderId,
        senderId: currentUserId,
        type: 'screenshare-answer',
        sdp: screensharePc.localDescription
      });
      screenshareContainer.classList.remove('hidden');
    }
    async function handleScreenshareAnswer(data) {
      const senderId = data.senderId;
      const screensharePc = screensharePeerConnections[senderId];
      if (screensharePc) {
        await screensharePc.setRemoteDescription(new RTCSessionDescription(data.sdp));
      }
    }
    async function handleScreenshareIceCandidate(data) {
      const senderId = data.senderId;
      const screensharePc = screensharePeerConnections[senderId];
      if (screensharePc && data.candidate) {
        await screensharePc.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    }
    function handleScreenshareEnd(data) {
      const senderId = data.senderId;
      if (screensharePeerConnections[senderId]) {
        screensharePeerConnections[senderId].close();
        delete screensharePeerConnections[senderId];
      }
      removeScreenshareStream(senderId);
      if (Object.keys(screensharePeerConnections).length === 0 && !isSharingScreen) {
        screenshareContainer.classList.add('hidden');
      }
    }
    function displayScreenshareStream(stream, senderId) {
      let videoElement = document.getElementById(`screenshare-video-${senderId}`);
      if (!videoElement) {
        videoElement = document.createElement('video');
        videoElement.id = `screenshare-video-${senderId}`;
        videoElement.autoplay = true;
        videoElement.playsinline = true;
        videoElement.classList.add('w-full', 'max-w-md', 'rounded-lg', 'shadow-lg', 'm-2');
        screenshareContainer.appendChild(videoElement);
      }
      videoElement.srcObject = stream;
    }
    function removeScreenshareStream(senderId) {
      const videoElement = document.getElementById(`screenshare-video-${senderId}`);
      if (videoElement) {
        videoElement.remove();
      }
    }
  </script>
</body>

</html>
