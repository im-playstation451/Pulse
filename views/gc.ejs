<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="32x32" src="/others/pulse.png">
  <title>Pulse - GC - <%= groupChat.name %></title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
  <style>
    .message-area::-webkit-scrollbar {
      width: 8px;
    }

    .message-area::-webkit-scrollbar-track {
      background: #2d3748;
    }

    .message-area::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }

    .message-area::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }

    body::-webkit-scrollbar {
      width: 4px;
    }

    body::-webkit-scrollbar-track {
      background: #1e1e1e;
    }

    body::-webkit-scrollbar-thumb {
      background: #7289da;
    }

    body::-webkit-scrollbar-thumb:hover {
      background: #6372e9;
    }
  </style>
  <style>
    .speaking-indicator {
      border: 2px solid #4CAF50;
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
    }
  </style>
  <style>
    .emoji-suggestions-scrollbar::-webkit-scrollbar {
      width: 8px;
    }

    .emoji-suggestions-scrollbar::-webkit-scrollbar-track {
      background: #2d3748;
    }

    .emoji-suggestions-scrollbar::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }

    .emoji-suggestions-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }
  </style>
</head>

<body
  class="bg-gray-800 font-sans text-white antialiased min-h-screen flex">

  <div
    class="flex flex-col flex-1 {{ 'ml-14 transition-all duration-200 hover:ml-40' if sidebar was present }}">
    <div class="sticky top-0 z-20">
      <header class="bg-gray-900 border-b border-gray-700 p-4 flex items-center justify-between shadow-md sticky top-0 z-20">
        <div class="flex items-center">
          <a href="/dashboard" class="mr-3">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
              stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
            </svg>
          </a>
          <button onclick="openChangeGcPictureModal('<%= groupChat.id %>')" class="w-10 h-10 rounded-full mr-3 flex items-center justify-center bg-blue-700 text-white text-sm font-bold hover:opacity-80 transition duration-150 relative group" title="Change Group Chat Picture">
            <% if (groupChat.picture) { %>
            <img src="<%= groupChat.picture %>" alt="<%= groupChat.name %> Picture" class="w-full h-full object-cover rounded-full">
            <% } else { %>
            GC
            <% } %>
            <div class="absolute inset-0 rounded-full bg-black bg-opacity-50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition duration-150">
              <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.218A2 2 0 0110.778 3h2.444a2 2 0 011.664.89l.812 1.218A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            </div>
          </button>
          <div class="flex flex-col">
            <div id="gcNameDisplay" class="text-xl font-semibold cursor-pointer"><%= groupChat.name %></div>
            <input type="text" id="gcNameInput" class="hidden text-xl font-semibold bg-gray-700 text-white p-1 rounded" value="<%= groupChat.name %>" />
            <p class="text-sm text-gray-400"><%= participants.length %> Members</p>
          </div>
        </div>
        <div class="flex items-center">
          <button onclick="openGroupChatModal('<%= groupChat.id %>')" class="p-2 rounded-full hover:bg-gray-700 transition text-gray-300 mr-2" title="Edit Group Chat">
            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm-6 14c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1H6v-1zm12-4h-2v-2h-2v2h-2v2h2v2h2v-2h2v-2z" fill="currentColor"/>
            </svg>
          </button>
          <button onclick="leaveGroupChat('<%= groupChat.id %>')" class="p-2 rounded-full hover:bg-red-700 transition text-red-300" title="Leave Group Chat">
            <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4M10 17l5-5-5-5M15 12H3"/>
            </svg>
          </button>
        </div>
      </header>

      <div id="callInteractionWrapper" class="sticky top-20 z-10">
        <div id="callActions" class="bg-gray-900 border-b border-gray-700 p-2 text-center text-sm">
          <button id="startCallButton" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full mr-2">Start Call</button>
          <button id="joinCallButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full hidden">Join Call</button>
        </div>

        <div id="callStatus" class="bg-gray-800 p-2 text-center text-sm hidden"></div>
        <div id="callControls" class="bg-gray-800 p-2 text-center text-sm hidden">
          <div id="callParticipants" class="flex items-center justify-center space-x-2 mb-2">
         </div>
         <div id="remoteAudioContainer" class="hidden"></div>
         <button id="muteButton" class="p-2 rounded-full hover:bg-gray-700">Mute</button>
         <button id="hangupButton" class="p-2 rounded-full hover:bg-red-700">Leave Call</button>
       </div>
      </div>


    <main class="flex-1 p-4 overflow-y-auto message-area">
      <div id="messages" class="space-y-2">
        <%
          function findUserById(userId, users) {
            return users.find(u => u.id === userId);
          }
        %>
        <% messages.forEach((message, index) => { %>
        <%
          let shouldGroup = false;
          const previousMessage = index > 0 ? messages[index - 1] : null;
          const sender = findUserById(message.senderId, users);
          
          if (previousMessage) {
            const currentSenderId = message.senderId;
            const previousSenderId = previousMessage.senderId;
            
            const currentTimestamp = new Date(message.timestamp);
            const previousTimestamp = new Date(previousMessage.timestamp);
            
            const sameSender = currentSenderId === previousSenderId;
            
            const sameMinute = currentTimestamp.getFullYear() === previousTimestamp.getFullYear() &&
                             currentTimestamp.getMonth() === previousTimestamp.getMonth() &&
                             currentTimestamp.getDate() === previousTimestamp.getDate() &&
                             currentTimestamp.getHours() === previousTimestamp.getHours() &&
                             currentTimestamp.getMinutes() === previousTimestamp.getMinutes();

            shouldGroup = sameSender && sameMinute;
          }
        %>
        <div class="message-item flex items-start hover:bg-gray-700/50 p-1 rounded-lg -mx-1 <%= shouldGroup ? '-mt-3' : '' %>" data-sender-id="<%= message.senderId %>" data-timestamp="<%= message.timestamp %>">
          <% if (!shouldGroup && sender) { %>
          <img src="<%= sender.profilepicture %>" alt="<%= sender.username %> Profile"
            class="w-10 h-10 rounded-full mr-4 mt-1">
          <% } else { %>
          <div class="w-10 h-10 mr-4"></div>
          <% } %>
          <div class="flex flex-col min-w-0">
            <% if (!shouldGroup && sender) { %>
            <div class="message-header flex items-baseline mb-1">
              <span class="font-semibold text-white mr-2"><%= sender.username %></span>
              <span class="text-xs text-gray-400"><%= new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) %></span>
            </div>
            <% } %>
            <% if (message.type === 'image') { %>
            <div class="max-w-full break-words">
              <img src="<%= message.content %>" alt="Image" class="max-w-full rounded-lg shadow-md" />
            </div>
            <% } else { %>
            <div class="text-white break-words max-w-full">
              <span class="encrypted-message" data-encrypted-content="<%= message.content %>">Loading...</span>
            </div>
            <% } %>
          </div>
        </div>
        <% }) %>
      </div>
    </main>

    <div class="bg-gray-900 border-t border-gray-700 p-4">
      <form id="messageForm" class="flex items-center gap-4">
        <div class="relative flex-grow">
          <input type="text" id="messageInput" placeholder="Type your message..."
            class="w-full p-3 rounded-full bg-gray-800 text-white focus:bg-gray-700 outline-none transition"
            autocomplete="off" />
          <div id="emojiSuggestions"
            class="absolute bottom-full left-0 mb-2 w-full bg-gray-800 rounded-lg shadow-lg p-2 hidden z-20 max-h-48 overflow-y-auto emoji-suggestions-scrollbar">
          </div>
        </div>
        <input type="file" id="fileInput" class="hidden" accept="image/*, image/gif" />
        <div class="relative">
          <label for="fileInput"
            class="cursor-pointer p-3 rounded-full hover:bg-gray-700 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13">
              </path>
            </svg>
          </label>
        </div>
        <button type="submit"
          class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-md transition duration-300">
          Send
        </button>
      </form>
      <div id="imagePreview" class="mt-2"></div>
    </div>
  </div>

<script>
    window.onload = function() {
      window.scrollTo(0,document.body.scrollHeight);
    };

    function openChangeGcPictureModal(groupId) {
      document.getElementById('gcIdPictureChange').value = groupId;
      document.getElementById('changeGcPictureModal').classList.remove('hidden');
    }

    function closeChangeGcPictureModal() {
      document.getElementById('changeGcPictureModal').classList.add('hidden');
      document.getElementById('gcPictureInput').value = '';
      document.getElementById('gcPicturePreview').innerHTML = '';
    }

    async function leaveGroupChat(groupId) {
      if (!confirm('Are you sure you want to leave this group chat?')) {
        return;
      }

      try {
        const encodedGroupId = encodeURIComponent(groupId);
        const response = await fetch(`/dashboard/gc/leave/${encodedGroupId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          window.location.href = '/dashboard';
        } else {
          const error = await response.json();
          alert(`Failed to leave group chat: ${error.message || response.statusText}`);
        }
      } catch (error) {
        console.error('Error leaving group chat:', error);
        alert('An unexpected error occurred while trying to leave the group chat.');
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const messageArea = document.querySelector('.message-area');
      const messageForm = document.getElementById('messageForm');
      const messageInput = document.getElementById('messageInput');
      const messagesDiv = document.getElementById('messages');
      const fileInput = document.getElementById('fileInput');
      const imagePreview = document.getElementById('imagePreview');
      const gcPictureInput = document.getElementById('gcPictureInput');
      const gcPicturePreview = document.getElementById('gcPicturePreview');
      const changeGcPictureForm = document.getElementById('changeGcPictureForm');
      const gcNameDisplay = document.getElementById('gcNameDisplay');
      const gcNameInput = document.getElementById('gcNameInput');
      const gcRoomId = '<%= groupChat.id %>';
      let currentImageFile = null;

      const customEmojis = {
        'cry': '/others/emojis/cry.png',
        'blue-what': '/others/emojis/blue-what.png',
        'cool-guy2': '/others/emojis/cool-guy2.png',
        'what': '/others/emojis/what.png',
        'cool-guy': '/others/emojis/cool-guy.png',
        'very-happy-troll': '/others/emojis/very-happy-troll.png'
      };

      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      function replaceEmojis(text) {
        let replacedText = text;
        let isOnlyEmoji = true;
        let emojiCount = 0;

        let tempText = text;
        for (const emojiName in customEmojis) {
          const escapedEmojiName = escapeRegExp(emojiName);
          const regex = new RegExp(`:${escapedEmojiName}:`, 'g');
          if (tempText.match(regex)) {
            emojiCount += (tempText.match(regex) || []).length;
            tempText = tempText.replace(regex, '');
          }
        }

        if (tempText.trim().length > 0 || emojiCount === 0) {
          isOnlyEmoji = false;
        }

        for (const emojiName in customEmojis) {
          const escapedEmojiName = escapeRegExp(emojiName);
          const regex = new RegExp(`:${escapedEmojiName}:`, 'g');
          const emojiClass = isOnlyEmoji ? 'inline-block w-16 h-16 align-middle' : 'inline-block w-5 h-5 align-text-bottom';
          replacedText = replacedText.replace(regex, `<img src="${customEmojis[emojiName]}" alt="${emojiName}" class="${emojiClass}" />`);
        }
        return replacedText;
      }
 
      const CDN_BASE_URL = '<%= process.env.CDN_BASE_URL %>';
      const CDN_UPLOAD_PATH = '<%= process.env.CDN_UPLOAD_PATH %>';
      const CDN_UPDATE_JSON_PATH = '/update-json';
      const AUTH_TOKEN = '<%= process.env.CDN_AUTH_TOKEN %>';


      function scrollToBottom() {
        window.scrollTo(0, document.body.scrollHeight);
      }

      function decryptSingleMessage(span) {
        const secretKey = '<%= process.env.CRYPTO_SECRET_KEY %>';
        const encryptedContent = span.dataset.encryptedContent;
        if (encryptedContent) {
          try {
            const bytes = CryptoJS.AES.decrypt(encryptedContent, secretKey);
            if (bytes.sigBytes <= 0) {
              console.error('Decryption failed: Resulting bytes are empty. Check if CRYPTO_SECRET_KEY is correct.');
              span.textContent = 'Failed to decrypt message (Invalid Key/Content)';
              return;
            }
            let decryptedContent = bytes.toString(CryptoJS.enc.Utf8);
            decryptedContent = replaceEmojis(decryptedContent);
            span.innerHTML = decryptedContent;
          } catch (error) {
            console.error('Decryption error for message:', error);
            span.textContent = 'Failed to decrypt message (Exception)';
          }
        }
      }

      function decryptExistingMessages() {
        document.querySelectorAll('.encrypted-message').forEach(decryptSingleMessage);
      }

      const checkCryptoJSInterval = setInterval(() => {
        if (typeof CryptoJS !== 'undefined' && CryptoJS.AES) {
          clearInterval(checkCryptoJSInterval);
          decryptExistingMessages();
        }
      }, 100);

      const observer = new MutationObserver(() => {
        scrollToBottom();
      });

      observer.observe(messagesDiv, { childList: true });

function findParticipantById(userId) {
  return participantsData.find(p => p.id === userId);
}

function displayMessage(msg) {
        const isCurrentUser = msg.senderId === '<%= user.id %>';
        const messageTimestamp = new Date(msg.timestamp);
        const sender = findParticipantById(msg.senderId);

        const lastMessageElement = messagesDiv.lastElementChild;
        let shouldGroup = false;

        if (lastMessageElement) {
          const lastSenderId = lastMessageElement.dataset.senderId;
          const lastTimestampStr = lastMessageElement.dataset.timestamp;
          
          if (lastSenderId && lastTimestampStr) {
            const lastTimestamp = new Date(lastTimestampStr);
            
            const sameSender = msg.senderId === lastSenderId;
            
            const sameMinute = messageTimestamp.getFullYear() === lastTimestamp.getFullYear() &&
                             messageTimestamp.getMonth() === lastTimestamp.getMonth() &&
                             messageTimestamp.getDate() === lastTimestamp.getDate() &&
                             messageTimestamp.getHours() === lastTimestamp.getHours() &&
                             messageTimestamp.getMinutes() === lastTimestamp.getMinutes();

            shouldGroup = sameSender && sameMinute;
          }
        }

        const messageContainer = document.createElement('div');
        messageContainer.classList.add('message-item', 'flex', 'items-start', 'hover:bg-gray-700/50', 'p-1', 'rounded-lg', '-mx-1');
        if (shouldGroup) {
          messageContainer.classList.add('mt-[-2]');
        }
        
        messageContainer.dataset.senderId = msg.senderId;
        messageContainer.dataset.timestamp = msg.timestamp;
        
        const profilePictureHtml = shouldGroup
          ? '<div class="w-10 h-10 mr-4"></div>'
          : `<img src="${sender ? sender.profilepicture : '<%= process.env.DEFAULT_PROFILE_PICTURE %>'} " alt="${sender ? sender.username : 'Unknown User'} Profile"
              class="w-10 h-10 rounded-full mr-4 mt-1">`;

        const headerHtml = shouldGroup
          ? ''
          : `<div class="message-header flex items-baseline mb-1">
                <span class="font-semibold text-white mr-2">${sender ? sender.username : 'Unknown User'}</span>
                <span class="text-xs text-gray-400">${messageTimestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
              </div>`;

        messageContainer.innerHTML = `
            ${profilePictureHtml}
            <div class="flex flex-col min-w-0">
              ${headerHtml}
              ${msg.type === 'image'
                ? `<div class="max-w-full break-words"><img src="${msg.content}" alt="Image" class="max-w-full rounded-lg shadow-md" /></div>`
                : `<div class="text-white break-words max-w-full"><span class="encrypted-message" data-encrypted-content="${msg.content}">Loading...</span></div>`
              }
            </div>
        `;
        messagesDiv.appendChild(messageContainer);
        
        if (msg.type === 'text') {
          const newSpan = messageContainer.querySelector('.encrypted-message');
          if (newSpan) {
            decryptSingleMessage(newSpan);
          }
        }
        
        scrollToBottom();
      }


function encryptMessage(content) {
  const secretKey = '<%= process.env.CRYPTO_SECRET_KEY %>';
  try {
    return CryptoJS.AES.encrypt(content, secretKey).toString();
  } catch (error) {
    console.error('Encryption error:', error);
    return content;
  }
}

async function saveMessageToCDN(messageData) {
  const payload = {
    folder: 'others',
    filename: `${gcRoomId}.json`,
    data: messageData
  };

  try {
    const response = await fetch(CDN_BASE_URL + CDN_UPDATE_JSON_PATH, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': AUTH_TOKEN,
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('CDN Save Message Failed:', response.status, response.statusText, errorText);
      throw new Error(`CDN Save Message Failed: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const data = await response.json();
  } catch (error) {
    console.error('Error saving message to CDN:', error);
    alert('Failed to save message history. Check console for details.');
  }
}

      socket.on('chat message', (msg) => {
        console.log('%cMessage received', 'color: blue;');
        displayMessage(msg);
      });

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          currentImageFile = file;
          imagePreview.innerHTML = `<img src="${URL.createObjectURL(file)}" alt="Preview" class="max-h-48 rounded-xl" />`;
        } else {
          currentImageFile = null;
          imagePreview.innerHTML = '';
        }
      });

      document.addEventListener('paste', async (event) => {
        const items = (event.clipboardData || event.clipboardData).items;
        let blob = null;

        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf("image") === 0) {
            blob = items[i].getAsFile();
            break;
          }
        }

          if (blob) {
            currentImageFile = blob;
            imagePreview.innerHTML = `<img src="${URL.createObjectURL(blob)}" alt="Preview" class="max-h-48 rounded-xl" />`;
            fileInput.value = '';
          }
      });

      async function uploadImageToCDN(file) {
        const formData = new FormData();
        const filename = `image-${Math.random().toString(36).substring(2, 22)}.png`;
        formData.append('file', file, filename);
        formData.append('folder', 'image');
        formData.append('filename', filename);
 
        try {
          const response = await fetch(CDN_BASE_URL + CDN_UPLOAD_PATH, {
            method: 'POST',
            headers: {
              'Authorization': AUTH_TOKEN,
            },
            body: formData,
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error('CDN Upload Failed:', response.status, response.statusText, errorText);
            alert(`CDN Upload Failed: ${response.status} ${response.statusText} - ${errorText}`);
            throw new Error(`CDN Upload Failed: ${response.status} ${response.statusText} - ${errorText}`);
          }

          const data = await response.json();
          console.log('CDN Upload Response (full data):', data);
          if (data && data.fileUrl) {
            return CDN_BASE_URL + data.fileUrl;
          } else {
            console.error('CDN Upload Response did not contain a fileUrl:', data);
            alert('Failed to upload image: CDN response missing fileUrl. Check console for full response.');
            return null;
          }
        } catch (error) {
          console.error('Error uploading image:', error);
          alert('Failed to upload image. Please try again. Check the console for details.');
          return null;
        }
      }

      messageForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const rawMessageContent = messageInput.value.trim();
        const timestamp = new Date().toISOString();

        if (!rawMessageContent && !currentImageFile) return;

        let imageUrl = null;

        if (currentImageFile) {
          imageUrl = await uploadImageToCDN(currentImageFile);
        }

        if (imageUrl) {
          const imageMessage = {
            senderId: '<%= user.id %>',
            groupId: '<%= groupChat.id %>',
            type: 'image',
            content: imageUrl,
            timestamp: timestamp
          };
          console.log('%cMessage sent', 'color: blue;');
          socket.emit('chat message', imageMessage);
          await saveMessageToCDN(imageMessage);

          imagePreview.innerHTML = '';
          fileInput.value = '';
          currentImageFile = null;
          scrollToBottom();
        } else if (currentImageFile) {
          console.error('Image URL is null, not emitting image message.');
          alert('Image upload failed, cannot send image message.');
        }

        if (rawMessageContent) {
          const encryptedContent = encryptMessage(rawMessageContent);
          const textMessage = {
            senderId: '<%= user.id %>',
            groupId: '<%= groupChat.id %>',
            type: 'text',
            content: encryptedContent,
            timestamp: timestamp
          };
          console.log('%cMessage sent', 'color: blue;');
          socket.emit('chat message', textMessage);
          await saveMessageToCDN(textMessage);

          messageInput.value = '';
          scrollToBottom();
        }
      });

      messageInput.addEventListener('input', () => {
        const text = messageInput.value;
        const colonIndex = text.lastIndexOf(':');

        if (colonIndex > -1 && (colonIndex === 0 || text[colonIndex - 1] === ' ' || text[colonIndex - 1] === '\n')) {
          const rawSearchTerm = text.substring(colonIndex + 1);
          const searchTerm = rawSearchTerm.trim().toLowerCase();
          const matchingEmojis = Object.keys(customEmojis).filter(emojiName =>
            emojiName.toLowerCase().startsWith(searchTerm)
          );

          displayEmojiSuggestions(matchingEmojis, colonIndex);
        } else {
          const emojiSuggestionsDiv = document.getElementById('emojiSuggestions');
          emojiSuggestionsDiv.classList.add('hidden');
          emojiSuggestionsDiv.innerHTML = '';
        }
      });

      const emojiSuggestionsDiv = document.getElementById('emojiSuggestions');

      function displayEmojiSuggestions(emojis, colonIndex) {
        emojiSuggestionsDiv.innerHTML = '';
        if (emojis.length > 0) {
          emojis.forEach(emojiName => {
            const emojiItem = document.createElement('div');
            emojiItem.classList.add('p-2', 'hover:bg-gray-700', 'cursor-pointer', 'flex', 'items-center');
            emojiItem.innerHTML = `<img src="${customEmojis[emojiName]}" alt="${emojiName}" class="inline-block w-5 h-5 mr-2" /> :${emojiName}:`;
            emojiItem.addEventListener('click', () => {
              const currentText = messageInput.value;
              const newText = currentText.substring(0, colonIndex) + `:${emojiName}: `;
              messageInput.value = newText;
              emojiSuggestionsDiv.classList.add('hidden');
              emojiSuggestionsDiv.innerHTML = '';
              messageInput.focus();
            });
            emojiSuggestionsDiv.appendChild(emojiItem);
          });
      
          emojiSuggestionsDiv.classList.remove('hidden');
        } else {
          emojiSuggestionsDiv.classList.add('hidden');
        }
      }

      document.addEventListener('click', (e) => {
        if (!emojiSuggestionsDiv.contains(e.target) && e.target !== messageInput) {
          emojiSuggestionsDiv.classList.add('hidden');
        }
      });
      gcPictureInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            gcPicturePreview.innerHTML = `<img src="${e.target.result}" alt="Preview" class="w-24 h-24 object-cover rounded-full shadow-md" />`;
          };
          reader.readAsDataURL(file);
        } else {
          gcPicturePreview.innerHTML = '';
        }
      });

      changeGcPictureForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const groupId = document.getElementById('gcIdPictureChange').value;
        const fileInput = document.getElementById('gcPictureInput');
        const file = fileInput.files[0];

        if (!file) {
          alert('Please select a file.');
          return;
        }

        const formData = new FormData();
        formData.append('picture', file);

        try {
          const response = await fetch(`/dashboard/gc/picture/${groupId}`, {
            method: 'POST',
            body: formData,
          });

          if (response.ok) {
            alert('Group chat picture updated successfully!');
            closeChangeGcPictureModal();
            window.location.reload();
          } else {
            const error = await response.json();
            alert(`Failed to update picture: ${error.message || response.statusText}`);
          }
        } catch (error) {
          console.error('Error updating group chat picture:', error);
          alert('An unexpected error occurred while trying to update the picture.');
        }
      });

      async function updateGroupChatName(groupId, newName) {
        try {
          const response = await fetch(`/dashboard/gc/name/${groupId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name: newName }),
          });

          if (response.ok) {
            console.log('Group chat name updated successfully!');
            document.title = `Pulse - GC - ${newName}`;
            return true;
          } else {
            const error = await response.json();
            alert(`Failed to update group chat name: ${error.message || response.statusText}`);
            return false;
          }
        } catch (error) {
          console.error('Error updating group chat name:', error);
          alert('An unexpected error occurred while trying to update the group chat name.');
          return false;
        }
      }

      gcNameDisplay.addEventListener('click', () => {
        gcNameDisplay.classList.add('hidden');
        gcNameInput.classList.remove('hidden');
        gcNameInput.focus();
        gcNameInput.select();
      });

      gcNameInput.addEventListener('blur', async () => {
        const newName = gcNameInput.value.trim();
        const originalName = gcNameDisplay.textContent.trim();

        if (newName && newName !== originalName) {
          const success = await updateGroupChatName(gcRoomId, newName);
          if (success) {
            gcNameDisplay.textContent = newName;
          } else {
            gcNameInput.value = originalName;
          }
        } else {
          gcNameInput.value = originalName;
        }

        gcNameInput.classList.add('hidden');
        gcNameDisplay.classList.remove('hidden');
      });

      gcNameInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          gcNameInput.blur(); 
        } else if (e.key === 'Escape') {
          gcNameInput.value = gcNameDisplay.textContent.trim();
          gcNameInput.classList.add('hidden');
          gcNameDisplay.classList.remove('hidden');
        }
      });
    });

    const socket = io();
    
    const currentUserId = '<%= user.id %>';
    const gcRoomId = '<%= groupChat.id %>';
    const participantsData = JSON.parse('<%- JSON.stringify(participants) %>');

    socket.emit('joinRoom', '<%= user.id %>');
    socket.emit('joinRoom', gcRoomId);

    const startCallButton = document.getElementById('startCallButton');
    const joinCallButton = document.getElementById('joinCallButton');
    const callStatusDiv = document.getElementById('callStatus');
    const callControlsDiv = document.getElementById('callControls');
    const callParticipantsDiv = document.getElementById('callParticipants');
    const muteButton = document.getElementById('muteButton');
    const hangupButton = document.getElementById('hangupButton');
    const callActionsDiv = document.getElementById('callActions');

    let peers = {};
    let localStream;
    let screenShareStream;
    let isMuted = false;
    let isSharingScreen = false;
    let callState = null;
    let signalQueue = {};

    startCallButton.addEventListener('click', async () => {
      if (!localStream) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          console.log('Local stream obtained:', localStream);
          muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
          localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
          setupAudioActivityDetection(localStream, currentUserId);
        } catch (err) {
          console.error('Error getting local media stream:', err);
          alert('Could not get microphone access. Please check your browser permissions.');
          return;
        }
      }
      console.log('Emitting start-call with callerId:', currentUserId, 'gcRoomId:', gcRoomId);
      socket.emit('start-call', { callerId: currentUserId, gcRoomId: gcRoomId });
    });
    joinCallButton.addEventListener('click', async () => {
      if (!localStream) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          console.log('Local stream obtained for joining call:', localStream);
          muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
          localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
          setupAudioActivityDetection(localStream, currentUserId);
        } catch (err) {
          console.error('Error getting local media stream for joining call:', err);
          alert('Could not get microphone access. Please check your browser permissions.');
          return;
        }
      }
      console.log('Emitting join-call with userId:', currentUserId, 'gcRoomId:', gcRoomId);
      socket.emit('join-call', { userId: currentUserId, gcRoomId: gcRoomId });
    });


    socket.on('webrtc-signal', async (data) => {
      const { gcRoomId: signalGcRoomId, senderId, signal } = data;
      if (signalGcRoomId !== gcRoomId) {
        console.warn('Received WebRTC signal for a different GC room, ignoring.', signalGcRoomId, gcRoomId);
        return;
      }

      if (senderId === currentUserId) {
        return;
      }

      let peer = peers[senderId];
      if (!peer) {
        console.log('Creating new peer for sender:', senderId, 'as non-initiator');
        if (!signalQueue[senderId]) {
          signalQueue[senderId] = [];
        }
        signalQueue[senderId].push(signal);
        peer = await createPeer(senderId, false);
        return;
      }

      if (signal.candidate) {
        try {
          console.log('Adding ICE candidate for', senderId, ':', signal.candidate);
          peer.addIceCandidate(signal.candidate);
        } catch (error) {
          console.error('Error adding ICE candidate for', senderId, ':', error);
        }
        return;
      }

      try {
        console.log('Signaling peer:', senderId, 'with signal:', signal);
        peer.signal(signal);
      } catch (error) {
        console.error('Error handling WebRTC signal for sender:', senderId, 'signal type:', signal.type, 'error:', error);
      }
    });

    muteButton.addEventListener('click', () => {
      if (localStream) {
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
      } else {
        console.warn('Cannot mute/unmute: localStream is not available.');
      }
    });

    hangupButton.addEventListener('click', () => {
      socket.emit('leave-call', { userId: currentUserId, gcRoomId: gcRoomId });
      handleCallEnd();
    });
    function handleCallEnd() {
      for (const peerId in peers) {
        if (peers[peerId]) {
          peers[peerId].destroy();
          delete peers[peerId];
        }
      }
      peers = {};

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (screenShareStream) {
        screenShareStream.getTracks().forEach(track => track.stop());
        screenShareStream = null;
      }
      isSharingScreen = false;

      callStatusDiv.textContent = 'Call Disconnected';
      callStatusDiv.classList.add('hidden');
      callControlsDiv.classList.add('hidden');
      callActionsDiv.classList.remove('hidden');
      startCallButton.classList.remove('hidden');
      joinCallButton.classList.add('hidden');
      callParticipantsDiv.innerHTML = '';
      callState = null;
    }
    async function createPeer(remoteUserId, isInitiator) {
      if (peers[remoteUserId]) {
        console.log(`Peer to ${remoteUserId} already exists.`);
        return peers[remoteUserId];
      }

      console.log('Initializing SimplePeer for', remoteUserId, 'initiator:', isInitiator, 'with localStream:', localStream);
      const peer = new SimplePeer({
        initiator: isInitiator,
        trickle: true,
        iceTransportPolicy: 'all',
        stream: localStream
      });

      if (signalQueue[remoteUserId] && signalQueue[remoteUserId].length > 0) {
        console.log(`Processing ${signalQueue[remoteUserId].length} queued signals for ${remoteUserId}`);
        signalQueue[remoteUserId].forEach(queuedSignal => {
          try {
            peer.signal(queuedSignal);
          } catch (error) {
            console.error('Error processing queued signal for', remoteUserId, ':', error);
          }
        });
        delete signalQueue[remoteUserId];
      }

      peers[remoteUserId] = peer;

      peer.on('signal', (signal) => {
        console.log('SimplePeer signal generated for', remoteUserId, ':', signal);
        socket.emit('webrtc-signal', {
          gcRoomId: gcRoomId,
          targetUserId: remoteUserId,
          senderId: currentUserId,
          signal: signal
        });
      });

      peer.on('iceCandidate', (candidate) => {
        console.log('ICE candidate generated for', remoteUserId, ':', candidate);
        socket.emit('webrtc-signal', {
          gcRoomId: gcRoomId,
          targetUserId: remoteUserId,
          senderId: currentUserId,
          signal: { candidate: candidate }
        });
      });

      peer.on('connect', () => {
        console.log('SimplePeer connected to', remoteUserId);
      });

      peer.on('stream', (stream) => {
        console.log('Remote stream received from:', remoteUserId, stream);
        const remoteAudio = new Audio();
        remoteAudio.autoplay = true; 
        remoteAudio.muted = true;
        remoteAudio.srcObject = stream;
        remoteAudio.id = `remote-audio-${remoteUserId}`;
        document.getElementById('remoteAudioContainer').appendChild(remoteAudio);

        remoteAudio.play().then(() => {
          console.log(`Remote audio from ${remoteUserId} started playing.`);
          remoteAudio.muted = false;
        }).catch(error => {
          console.warn(`Autoplay prevented for ${remoteUserId}. User interaction might be needed.`, error);
        });
        setupAudioActivityDetection(stream, remoteUserId);
      });

      peer.on('close', () => {
        console.log('Peer to', remoteUserId, 'closed.');
        delete peers[remoteUserId];
      });

      peer.on('error', (err) => {
        console.error('SimplePeer error for', remoteUserId, ':', err);
      });

      return peer;
    }
    async function joinCallRoom() {
      callStatusDiv.textContent = 'Connecting...';
      callStatusDiv.classList.remove('hidden');
      callControlsDiv.classList.remove('hidden');
      callActionsDiv.classList.add('hidden');
      if (callState && callState.participants) {
        for (const participantId of callState.participants) {
          if (participantId !== currentUserId) {
            await createPeer(participantId, true);
          }
        }
      }
    }
    socket.on('call-state-update', async (data) => {
      const { gcRoomId: updatedGcRoomId, call } = data;
      if (updatedGcRoomId !== gcRoomId) {
        console.warn('Received call-state-update for a different GC room, ignoring.', updatedGcRoomId, gcRoomId);
        return;
      }
      callState = call;
      if (callState) {
        callActionsDiv.classList.add('hidden');
        callControlsDiv.classList.remove('hidden');
        callStatusDiv.classList.remove('hidden');
        callStatusDiv.textContent = 'Call Active';
        callParticipantsDiv.innerHTML = '';
        const usersInCall = callState.participants.map((pId) => {
          const participant = participantsData.find(p => p.id === pId);
          if (participant) {
            return participant;
          } else {
            return { id: pId, username: 'Unknown User', profilepicture: '<%= process.env.DEFAULT_PROFILE_PICTURE %>' };
          }
        });
        usersInCall.forEach(p => {
          const participantElement = document.createElement('div');
          participantElement.classList.add('flex', 'items-center', 'space-x-1');
          participantElement.innerHTML = `
            <img id="participant-${p.id}" src="${p.profilepicture}" alt="${p.username} Profile" class="w-6 h-6 rounded-full">
            <span class="text-sm">${p.username}</span>
          `;
          callParticipantsDiv.appendChild(participantElement);
          if (p.id === currentUserId && localStream) {
            setupAudioActivityDetection(localStream, currentUserId);
          }
        });
        const currentParticipants = Object.keys(peers);
        const newParticipants = callState.participants.filter(pId => pId !== currentUserId && !currentParticipants.includes(pId));
        const leavingParticipants = currentParticipants.filter(pId => !callState.participants.includes(pId));
        for (const newPId of newParticipants) {
          const shouldInitiate = currentUserId < newPId;
          if (shouldInitiate) {
            console.log(`User ${currentUserId} initiating peer to ${newPId}`);
            await createPeer(newPId, true);
          } else {
            console.log(`User ${currentUserId} waiting for peer initiation from ${newPId}`);
          }
        }
        for (const leavingPId of leavingParticipants) {
          if (peers[leavingPId]) {
            peers[leavingPId].destroy();
            delete peers[leavingPId];
            console.log(`Destroyed peer connection to leaving participant: ${leavingPId}`);
          }
        }
      } else {
        handleCallEnd();
        callActionsDiv.classList.remove('hidden');
        startCallButton.classList.remove('hidden');
        joinCallButton.classList.add('hidden');
      }
      if (callState && callState.participants.length > 0 && !callState.participants.includes(currentUserId)) {
        joinCallButton.classList.remove('hidden');
        startCallButton.classList.add('hidden');
      } else if (callState && callState.participants.includes(currentUserId)) {
        startCallButton.classList.add('hidden');
        joinCallButton.classList.add('hidden');
      } else {
        startCallButton.classList.remove('hidden');
        joinCallButton.classList.add('hidden');
      }
    });
    function setupAudioActivityDetection(stream, userId) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const analyser = audioContext.createAnalyser();
      const microphone = audioContext.createMediaStreamSource(stream);
      const scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);

      analyser.smoothingTimeConstant = 0.8;
      analyser.fftSize = 1024;

      microphone.connect(analyser);
      analyser.connect(scriptProcessor);
      scriptProcessor.connect(audioContext.destination);

      const buffer = new Uint8Array(analyser.fftSize);

      scriptProcessor.onaudioprocess = () => {
        analyser.getByteTimeDomainData(buffer);
        let sum = 0;
        for (let i = 0; i < buffer.length; i++) {
          sum += (buffer[i] - 128) * (buffer[i] - 128);
        }
        const rms = Math.sqrt(sum / buffer.length);

        const participantElement = document.getElementById(`participant-${userId}`);
        if (participantElement) {
          if (rms > 1) {
            participantElement.classList.add('speaking-indicator');
          } else {
            participantElement.classList.remove('speaking-indicator');
          }
        }
      };
    }
  </script>
<%- include('parts/gc-icon') %>
<%- include('parts/gc-create', { user: user }) %>
</body>

</html>